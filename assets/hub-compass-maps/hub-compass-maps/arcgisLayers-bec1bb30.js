import { d6 as p$1, f as s, db as c$1, gm as d$1, gn as Ct, c2 as L } from './hub-compass-map-f4225e12.js';
import { t, r } from './fetchService-f2cb8e89.js';
import { a } from './lazyLayerLoader-776bcaa9.js';
import './index-d436d5f8.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const c={FeatureLayer:!0,SceneLayer:!0};async function i(e){const r=e.properties?.customParameters,a=await p(e.url,r),t={...e.properties,url:e.url};if(!a.sublayerIds)return null!=a.layerOrTableId&&(t.layerId=a.layerOrTableId,t.sourceJSON=a.sourceJSON),new a.Constructor(t);const s=new(0,(await import('./GroupLayer-63c28f3b.js')).default)({title:a.parsedUrl.title});return m(s,a,t),s}function y(e,r){return e?e.find((e=>e.id===r)):null}function m(e,r,a){function t(e,t){const s={...a,layerId:e,sublayerTitleMode:"service-name"};return null!=t&&(s.sourceJSON=t),new r.Constructor(s)}r.sublayerIds.forEach((a=>{const s=t(a,y(r.sublayerInfos,a));e.add(s);})),r.tableIds.forEach((a=>{const s=t(a,y(r.tableInfos,a));e.tables.add(s);}));}async function p(r,a){let s$1=p$1(r);if(null==s$1&&(s$1=await d(r,a)),null==s$1)throw new s("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:l,sublayer:o}=s$1;let i;const y={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(l){case"MapServer":if(null!=o)i="FeatureLayer";else {i=await S(r,a)?"TileLayer":"MapImageLayer";}break;case"ImageServer":{const e=await t(r,{customParameters:a}),{tileInfo:t$1,cacheType:s}=e;i=t$1?"LERC"!==t$1?.format?.toUpperCase()||s&&"elevation"!==s.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await t(s$1.url.path,{customParameters:a});if(i="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)i="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=c$1[e]&&(i=c$1[e]);}}break}default:i=y[l];}const m="FeatureServer"===l,p={parsedUrl:s$1,Constructor:null,layerOrTableId:m?o:void 0,sublayerIds:null,tableIds:null};if(c[i]&&null==o){const e=await I(r,l,a);m&&(p.sublayerInfos=e.layerInfos,p.tableInfos=e.tableInfos);1!==e.layerIds.length+e.tableIds.length?(p.sublayerIds=e.layerIds,p.tableIds=e.tableIds):m&&(p.layerOrTableId=e.layerIds[0]??e.tableIds[0],p.sourceJSON=e.layerInfos?.[0]??e.tableInfos?.[0]);}return p.Constructor=await b(i),p}async function d(e,t$1){const l=await t(e,{customParameters:t$1});let n=null,o=null;const c=l.type;if("Feature Layer"===c||"Table"===c?(n="FeatureServer",o=l.id??null):"indexedVector"===c?n="VectorTileServer":l.hasOwnProperty("mapName")?n="MapServer":l.hasOwnProperty("bandCount")&&l.hasOwnProperty("pixelSizeX")?n="ImageServer":l.hasOwnProperty("maxRecordCount")&&l.hasOwnProperty("allowGeometryUpdates")?n="FeatureServer":l.hasOwnProperty("streamUrls")?n="StreamServer":f(l)?(n="SceneServer",o=l.id):l.hasOwnProperty("layers")&&f(l.layers?.[0])&&(n="SceneServer"),!n)return null;const i=null!=o?d$1(e):null;return {title:null!=i&&l.name||Ct(e),serverType:n,sublayer:o,url:{path:null!=i?i.serviceUrl:L(e).path}}}function f(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function I(e,r$1,a){let t$1,s=!1;if("FeatureServer"===r$1){const r$1=await r(e,{customParameters:a});s=!!r$1.layersJSON,t$1=r$1.layersJSON||r$1.serviceJSON;}else t$1=await t(e,{customParameters:a});const n=t$1?.layers,o=t$1?.tables;return {layerIds:n?.map((e=>e.id)).reverse()||[],tableIds:o?.map((e=>e.id)).reverse()||[],layerInfos:s?n:[],tableInfos:s?o:[]}}async function b(e){return (0,a[e])()}async function S(e,r){return (await t(e,{customParameters:r})).tileInfo}

export { i as fromUrl };

//# sourceMappingURL=arcgisLayers-bec1bb30.js.map