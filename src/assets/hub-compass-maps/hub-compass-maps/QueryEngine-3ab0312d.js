import { bJ as e$1, c7 as s, f as s$1, dH as i, by as s$2, bz as S, gP as ae, gQ as v$2, gR as l$1, ar as o$1, gS as l$2, gT as r$1, gU as s$3, bX as r$2, D as o$2, H as l$3, cM as b$1, bW as p$2, j as s$4, gV as O, fI as i$1, fG as C, fK as o$3, ca as H, gW as C$1, aQ as a$1, gX as v$5, gY as b$2, aI as m$3, bj as a$2, aq as f$4, ay as a$3, ap as i$2 } from './hub-compass-map-68308039.js';
import { r as rt } from './featureConversionUtils-e451106b.js';
import { f as f$1 } from './WhereClause-d316cbe1.js';
import { g as g$1, f as f$3, M as M$2 } from './projectionSupport-1d172051.js';
import { t as t$2 } from './QueryEngineCapabilities-3153ed38.js';
import { m as m$2 } from './quantizationUtils-0ef46038.js';
import { P, Z, G, M as M$1, t as t$3, v as v$3, a as v$4, n as n$2, I, b as P$1 } from './timeSupport-cb96dffc.js';
import { c as c$2, z as z$1, m as m$1, f as f$2, d as d$1, g as g$2, x as x$1, F as F$1, D, S as S$1, M, v as v$1, p as p$1 } from './utils-df6099d4.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
class c$1{constructor(e,c){this._cache=new e$1(e),this._invalidCache=new e$1(c);}get(t,c){const i=`${c.uid}:${t}`,r=this._cache.get(i);if(r)return r;if(void 0!==this._invalidCache.get(i))return null;try{const r=f$1.create(t,c);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const n$1=new c$1(50,500),r="feature-store:unsupported-query",t$1=" as ",o=new s({esriFieldTypeString:"string"}),a=new s({esriFieldTypeOID:"oid",esriFieldTypeSmallInteger:"small-integer",esriFieldTypeInteger:"integer",esriFieldTypeSingle:"single",esriFieldTypeDouble:"double",esriFieldTypeLong:"long"}),l=new s({esriFieldTypeDate:"date"}),d=new s({esriFieldTypeGUID:"guid",esriFieldTypeGlobalId:"global-id"}),p=new Set([...a.jsonValues,...l.jsonValues,...o.jsonValues,...d.jsonValues]),u=new Intl.ListFormat("en-US",{type:"conjunction"}).format([...a.apiValues,...l.apiValues,...o.apiValues,...d.apiValues]);function g(s,i,n={}){const t=y(s,i);if(!t)throw new s$1(r,"invalid SQL expression",{expression:s});const o=n.expressionName||"expression";if(n.validateStandardized&&!t.isStandardized)throw new s$1(r,`${o} is not standard`,{expression:s});if(n.validateAggregate&&!t.isAggregate)throw new s$1(r,`${o} does not contain a valid aggregate function`,{expression:s});return t.fieldNames}function c(e,s,i){if(!s)return !0;const n="where clause",r=g(s,e,{validateStandardized:!0,expressionName:n});return m(e,r,{expressionName:n,query:i}),x(e,r,{expressionName:n,query:i}),!0}function f(s,i,t,o){if(!i)return !0;const a="having",l=g(i,s,{validateAggregate:!0,expressionName:a});m(s,l,{expressionName:a,query:o}),x(s,l,{expressionName:a,query:o});const d=n$1.get(i,s),p=d?.getExpressions().every((e=>{const{aggregateType:i,field:n}=e,r=s.get(n)?.name;return t.some((e=>{const{onStatisticField:n,statisticType:t}=e,o=s.get(n)?.name;return o===r&&t.toLowerCase().trim()===i}))}));if(!p)throw new s$1(r,"expressions in having should also exist in outStatistics",{having:i});return !0}function y(e,s){return e?n$1.get(e,s):null}function m(e,s,i={}){i.errorMessage||(i.errorMessage=i.expressionName?`${i.expressionName} contains invalid fields`:"Fields are invalid"),h(e,s,((e,s)=>s.has(e)),i);}function x(e,s,i={}){i.errorMessage||(i.errorMessage=i.expressionName?`${i.expressionName} only supports ${u} field types`:`Only ${u} field types are supported`),h(e,s,((e,s)=>!F(e,s)),i);}function h(s,i,n,t={}){const o=t.verifyExpression??!0,a=[];for(const e of i){const i=n(e,s);if("*"!==e&&!i)if(o){const i=w(e);try{h(s,g(i,s,{validateStandardized:!0}),n,t);}catch(l){const s=l?.details;if(s?.expression)throw l;s?.invalidFields?a.push(...s.invalidFields):a.push(e);}}else a.push(e);}if(a.length)throw new s$1(r,t.errorMessage,{invalidFields:a,query:t.query})}function w(e){return e.split(t$1)[0]}function v(e){return e.split(t$1)[1]}function F(e,s,i=p){const n=s.get(e);return !!n&&!i.has(n.type)}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
class n{constructor(s,a,l){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=s.returnDistinctValues??!1,this.fieldsIndex=l,this.featureAdapter=a;const r=s.outFields;if(r&&!r.includes("*")){this.outFields=r;let s=0;for(const a of r){const r=w(a),n=this.fieldsIndex.get(r),u=n?null:y(r,l),d=n?n.name:v(a)||"FIELD_EXP_"+s++;this._fieldDataCache.set(a,{alias:d,clause:u});}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,i,s){const a=s?s.name:i;let l=null;return this._fieldDataCache.has(a)?l=this._fieldDataCache.get(a)?.clause:s||(l=y(i,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:l})),s?this.featureAdapter.getAttribute(t,a):l?.calculateValue(t,this.featureAdapter)}getDataValues(t,e){const i=e.normalizationType,s=e.normalizationTotal;return t.map((t=>{let r=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(r=`${c$2(r)}${e.fieldDelimiter}${c$2(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(r=`${r}${e.fieldDelimiter}${c$2(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(r)){const a="field"===i&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;r=z$1(r,i,a,s);}return r}))}async getExpressionValues(t,e,i$1,a){const{arcadeUtils:l}=await i(),n=l.hasGeometryOperations(e);n&&await l.enableGeometryOperations();const u=l.createFunction(e),d=i$1&&l.getViewInfo(i$1),o={fields:this.fieldsIndex.fields};return t.map((t=>{const e={attributes:this.featureAdapter.getAttributes(t),layer:o,geometry:n?{...P(a.geometryType,a.hasZ,a.hasM,this.featureAdapter.getGeometry(t)),spatialReference:i$1?.spatialReference}:null},r=l.createExecContext(e,d);return l.executeFunction(u,r)}))}validateItem(t,i){return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:y(i,this.fieldsIndex)}),this._fieldDataCache.get(i)?.clause?.testFeature(t,this.featureAdapter)??!1}validateItems(t,i){return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:y(i,this.fieldsIndex)}),this._fieldDataCache.get(i)?.clause?.testSet(t,this.featureAdapter)??!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const s of e){const{alias:e,clause:a}=this._fieldDataCache.get(s);i[e]=a?a.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,e);}return i}_processAttributesForDistinctValues(t){if(null==t||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const l of e){const{alias:e}=this._fieldDataCache.get(l);i.push(t[e]);}else for(const l in t)i.push(t[l]);const s=`${(e||["*"]).join(",")}=${i.join(",")}`;let a=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++a),a>1?null:t}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function t(t,e,r){return {objectId:t,target:e,distance:r,type:"vertex"}}function e(t,e,r,n,d,a=!1){return {objectId:t,target:e,distance:r,type:"edge",start:n,end:d,draped:a}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
class z{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter;}get size(){return this.items.length}createQueryResponseForCount(){const e=new n(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query,a=t?.length;if(!!!a)return 1;const r=new Map,n$1=new Map,l=new Set;for(const o of i){const{statisticType:i}=o,a="exceedslimit"!==i?o.onStatisticField:void 0;if(!n$1.has(a)){const s=[];for(const i of t){const t=this._getAttributeValues(e,i,r);s.push(t);}n$1.set(a,this._calculateUniqueValues(s,e.returnDistinctValues));}const u=n$1.get(a);for(const t in u){const{data:i,items:a}=u[t],r=i.join(",");s&&!e.validateItems(a,s)||l.add(r);}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query);}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;s$2(this.query.outSR)&&!S(t.spatialReference,this.query.outSR)?e.queryGeometry=Z({spatialReference:this.query.outSR,...g$1(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=Z({spatialReference:this.query.outSR,...t});}return e}createSnappingResponse(e$1,t$1){const s=this.featureAdapter,i=b(this.hasZ,this.hasM),{point:a,mode:r}=e$1,n="number"==typeof e$1.distance?e$1.distance:e$1.distance.x,o="number"==typeof e$1.distance?e$1.distance:e$1.distance.y,l={candidates:[]},d="esriGeometryPolygon"===this.geometryType,m=this._getPointCreator(r,this.spatialReference,t$1),h=new A(null,0),g=new A(null,0),f={x:0,y:0,z:0};for(const p of this.items){const t$1=s.getGeometry(p);if(null==t$1)continue;const{coords:r,lengths:y}=t$1;if(h.coords=r,g.coords=r,e$1.returnEdge){let e$1=0;for(let t=0;t<y.length;t++){const r=y[t];for(let t=0;t<r;t++,e$1+=i){const c=h;if(c.coordsIndex=e$1,t!==r-1){const t=g;t.coordsIndex=e$1+i;const r=f;R(f,a,c,t);const d=(a.x-r.x)/n,h=(a.y-r.y)/o,y=d*d+h*h;y<=1&&l.candidates.push(e(s.getObjectId(p),m(r),Math.sqrt(y),m(c),m(t)));}}}}if(e$1.returnVertex){const e=d?r.length-i:r.length;for(let t$1=0;t$1<e;t$1+=i){const e=h;e.coordsIndex=t$1;const i=(a.x-e.x)/n,r=(a.y-e.y)/o,u=i*i+r*r;u<=1&&l.candidates.push(t(s.getObjectId(p),m(e),Math.sqrt(u)));}}}return l.candidates.sort(((e,t)=>e.distance-t.distance)),l}_getPointCreator(e,t,s){const i=null==s||S(t,s)?e=>e:e=>g$1(e,t,s),{hasZ:a}=this,r=0;return "3d"===e?a?({x:e,y:t,z:s})=>i({x:e,y:t,z:s}):({x:e,y:t})=>i({x:e,y:t,z:r}):({x:e,y:t})=>i({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:l}),d=m$1({normalizationType:a,normalizationField:i,minValue:n,maxValue:o}),m=this.fieldsIndex.get(t),h={value:.5,fieldType:m?.type},I=ae(m)?f$2({values:c,supportsNullCount:d,percentileParams:h}):d$1({values:c,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:d,percentileParams:h});return g$2(I,u)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domains:i,returnAllCodedValues:a,scale:r}=e,n=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:s,scale:r}),o=x$1(n);return F$1(o,i,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d}=e,m=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:d}),h=D(m,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return S$1(h,n)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d}=e,m=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:d});return M(m,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const t=i.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=!!t[1]&&"desc"===t[1].toLowerCase(),o=v$1(r?.type,n);e.sort(((e,t)=>{const i=s(e,a,r),n=s(t,a,r);return o(i,n)}));}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:r,objectIdField:n,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:m,resultOffset:h,returnZ:g,returnM:f}=e,p=null!=m&&t.length>(h||0)+m,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return {exceededTransferLimit:p,features:this._createFeatures(e,t),fields:y,geometryType:s,hasM:i&&f,hasZ:r&&g,objectIdFieldName:n,spatialReference:Z(u||o),transform:c&&m$2(c)||null}}_createFeatures(e,t){const s=new n(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:r}=this,{orderByFields:n$1,quantizationParameters:l,returnGeometry:u,returnCentroid:c,maxAllowableOffset:d,resultOffset:g,resultRecordCount:f,returnZ:p=!1,returnM:y=!1}=e,x=r&&p,I=i&&y;let T=[],V=0;const F=[...t];if(this._sortFeatures(F,n$1,((e,t,i)=>s.getFieldValue(e,t,i))),u||c){const e=m$2(l)??void 0;if(u&&!c)for(const t of F)T[V++]={attributes:s.getAttributes(t),geometry:P(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,x,I)};else if(!u&&c)for(const t of F)T[V++]={attributes:s.getAttributes(t),centroid:G(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)T[V++]={attributes:s.getAttributes(t),centroid:G(this,this.featureAdapter.getCentroid(t,this),e),geometry:P(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,x,I)};}else for(const a of F){const e=s.getAttributes(a);e&&(T[V++]={attributes:e});}const S=g||0;if(null!=f){const e=S+f;T=T.slice(S,Math.min(T.length,e));}return T}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const r of e.outStatistics??[])if("exceedslimit"===r.statisticType){s=null!=r.maxPointCount?r.maxPointCount:Number.POSITIVE_INFINITY,i=null!=r.maxRecordCount?r.maxRecordCount:Number.POSITIVE_INFINITY,a=null!=r.maxVertexCount?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>s;else if(this.items.length>i)t=!0;else {const e=b(this.hasZ,this.hasM),s=this.featureAdapter;t=this.items.reduce(((e,t)=>{const i=s.getGeometry(t);return e+(null!=i&&i.coords.length||0)}),0)/e>a;}return {fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,a=new Map,r=new Map,n$1=new Map,l=new n(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=e,h=c&&c.length,g=!!h,f=g?c[0]:null,p=g&&!this.fieldsIndex.get(f);for(const o of u??[]){const{outStatisticFieldName:e,statisticType:u}=o,m=o,y="exceedslimit"!==u?o.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,I="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,T=g&&1===h&&(y===f||p)&&"count"===u;if(g){if(!r.has(y)){const e=[];for(const t of c){const s=this._getAttributeValues(l,t,i);e.push(s);}r.set(y,this._calculateUniqueValues(e,!I&&l.returnDistinctValues));}const t=r.get(y);for(const s in t){const{count:a,data:r,items:o,itemPositions:u}=t[s],h=r.join(",");if(!d||l.validateItems(o,d)){const t=n$1.get(h)||{attributes:{}};if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(m,o);t.aggregateGeometries[s]=e;}else {let s=null;if(T)s=a;else {const e=this._getAttributeValues(l,y,i),t=u.map((t=>e[t]));s=x&&"statisticParameters"in m?this._getPercentileValue(m,t):this._getStatisticValue(m,t,null,l.returnDistinctValues);}t.attributes[e]=s;}let s=0;c.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++s]=r[i])),n$1.set(h,t);}}}else if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(m,this.items);t.aggregateGeometries[s]=e;}else {const s=this._getAttributeValues(l,y,i);t.attributes[e]=x&&"statisticParameters"in m?this._getPercentileValue(m,s):this._getStatisticValue(m,s,a,l.returnDistinctValues);}s.push({name:e,alias:e,type:"esriFieldTypeDouble"});}const y=g?Array.from(n$1.values()):[t];return this._sortFeatures(y,m,((e,t)=>e.attributes[t])),{fields:s,features:y}}async _getAggregateGeometry(a,r){const{convexHull:n,union:o}=await import('./geometryEngineJSON-24b29b6b.js'),{statisticType:l,outStatisticFieldName:u}=a,{featureAdapter:c,spatialReference:d,geometryType:h,hasZ:g,hasM:f}=this,p=r.map((e=>P(h,g,f,c.getGeometry(e)))),y=n(d,p,!0)[0],x={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===l){const e=y?v$2(y):l$1(o(d,p));x.aggregateGeometries={...e,spatialReference:d},x.outStatisticFieldName=u||"extent";}else if("CentroidAggregate"===l){const s=y?o$1(y):l$2(l$1(o(d,p)));x.aggregateGeometries={x:s[0],y:s[1],spatialReference:d},x.outStatisticFieldName=u||"centroid";}else "ConvexHullAggregate"===l&&(x.aggregateGeometries=y,x.outStatisticFieldName=u||"convexHull");return x}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:r}=e;let n=null;n=s?.has(a)?s.get(a):ae(this.fieldsIndex.get(a))?f$2({values:t,returnDistinct:i}):d$1({values:i?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:r,orderBy:n}=i,o=this.fieldsIndex.get(s);return p$1(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),a=this.items.map((s=>e.getFieldValue(s,t,i)));return s.set(t,a),a}_calculateUniqueValues(e,t){const s={},i=this.items,a=i.length;for(let r=0;r<a;r++){const a=i[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");null==s[o]?s[o]={count:1,data:n,items:[a],itemPositions:[r]}:(t||s[o].count++,s[o].items.push(a),s[o].itemPositions.push(r));}return s}async _getDataValues(e){const t=new n(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,scale:i}=e,a=s?{viewingMode:"map",scale:i,spatialReference:this.query.outSR||this.spatialReference}:null;return s?t.getExpressionValues(this.items,s,a,{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM}):t.getDataValues(this.items,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal})}}function R(e,t,s,i){const a=i.x-s.x,r=i.y-s.y,n=a*a+r*r,o=(t.x-s.x)*a+(t.y-s.y)*r,l=Math.min(1,Math.max(0,o/n));e.x=s.x+a*l,e.y=s.y+r*l;}function b(e,t){return e?t?4:3:t?3:2}class A{constructor(e,t){this.coords=e,this.coordsIndex=t;}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function $(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}const W="feature-store:unsupported-query";class K{constructor(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t;}}const X=new r$1(2e6);let Y=0;class ee{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:t$2},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new s$3(Y+++"$$",X)),this.fieldsIndex=new r$2(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority));}destroy(){this._frameTask=o$2(this._frameTask),this.clearCache(),l$3(this._geometryQueryCache),this._changeHandle=o$2(this._changeHandle),l$3(this.fieldsIndex);}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null;}async executeQuery(e,t){try{return (await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==M$1)throw i;return new z([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return (await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==M$1)throw i;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=s.size;if(!r)return {count:0,extent:null};return {count:r,extent:await this._getBounds(s.items,s.spatialReference,i||this.spatialReference)}}catch(s){if(s===M$1)return {count:0,extent:null};throw s}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=i.items,r=new Set;return await this._reschedule((()=>{for(const e of s)r.add(i.featureAdapter.getObjectId(e));}),t),r}catch(i){if(i===M$1)return new Set;throw i}}async executeQueryForSnapping(e,t){const{point:i,distance:s,returnEdge:r,returnVertex:a}=e;if(!r&&!a)return {candidates:[]};const n=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),u=!S(i.spatialReference,this.spatialReference);u&&await f$3(i.spatialReference,this.spatialReference);const o="number"==typeof s?s:s.x,l="number"==typeof s?s:s.y,c={xmin:i.x-o,xmax:i.x+o,ymin:i.y-l,ymax:i.y+l,spatialReference:i.spatialReference},h=u?g$1(c,this.spatialReference):c;if(!h)return {candidates:[]};const p=(await b$1(p$2(i),null,{signal:t}))[0],m=(await b$1(p$2(h),null,{signal:t}))[0];if(null==p||null==m)return {candidates:[]};const f=new z(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(m.toJSON()))),t),n,this);await this._reschedule((()=>this._executeObjectIdsQuery(f)),t),await this._reschedule((()=>this._executeTimeQuery(f)),t),await this._reschedule((()=>this._executeAttributesQuery(f)),t);const d=p.toJSON(),y=u?g$1(d,this.spatialReference):d,_=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return f.createSnappingResponse({...e,point:y,distance:_},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new s$1(W,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(s){if(s!==M$1)throw s;return new z([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,field2:r,field3:a,valueExpression:n}=t;return (await this._getQueryEngineResultForStats(e,{field:s,field2:r,field3:a,valueExpression:n},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const[t,i]=await Promise.all(["getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getBounds(await this._getAllFeatures(),this.spatialReference,this.spatialReference),null!=this._timeExtentPromise?this._timeExtentPromise:this._timeExtentPromise=t$3(this.timeInfo,this.featureStore)]);return s$4(e),{fullExtent:t,timeExtent:i}}async _getBounds(e,t,i){const s=O(i$1(),C);await this.featureStore.forEachBounds(e,(e=>o$3(s,e)));const r={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:Z(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(r.zmin=s[2],r.zmax=s[5]);const a=g$1(r,t,i);if(a.spatialReference=Z(i),a.xmax-a.xmin==0){const e=H(a.spatialReference);a.xmin-=e,a.xmax+=e;}if(a.ymax-a.ymin==0){const e=H(a.spatialReference);a.ymin-=e,a.ymax+=e;}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=H(a.spatialReference);a.zmin-=e,a.zmax+=e;}return a}async _schedule(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(C$1)}async _reschedule(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(C$1)}async _getAllFeaturesQueryEngineResult(e){return new z(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)));})().then((()=>e));}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=a$1(e),e=await this._schedule((()=>v$3(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e={...e,...t};const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,u=null==a||S(a,n.spatialReference)?n:g$1(n,a);if(!u)return null;const o=s||r,l=s$2(i)&&!S(this.spatialReference,i)&&o?async e=>this._project(e,i):e=>e,c=this.featureAdapter,h=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(u))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!h.length)return null;const i=new Set;for(const e of h)i.add(c.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),r=await this._reschedule((async()=>{const r=await v$4("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(c.getObjectId(e))||r(c.getGeometry(e)),n=await this._runSpatialFilter(s,a,t);return new z(n,e,this)}),t);return l(r)}if(!h.length)return new z([],e,this);if(this._canExecuteSinglePass(u,e))return l(new z(h,e,this));const p=await v$4("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(h,(e=>p(c.getGeometry(e))),t);return l(new z(m,e,this))}async _executeGeometryQuery(i,s,r){if(null!=s&&0===s.items.length)return s;i=null!=s?s.query:i;const{geometry:a,outSR:n,spatialRel:u,returnGeometry:o,returnCentroid:l}=i,c=this.featureStore.featureSpatialReference,h=!a||null==c||S(c,a.spatialReference)?a:g$1(a,c),p=o||l,m=s$2(n)&&!S(this.spatialReference,n),f=this._geometryQueryCache&&null==s?m&&p?JSON.stringify({originalFilterGeometry:a,spatialRelationship:u,outSpatialReference:n}):JSON.stringify({originalFilterGeometry:a,spatialRelationship:u}):null,d=f?this._geometryQueryCache.get(f):null;if(null!=d)return new z(d,i,this);const y=async e=>(m&&p&&await this._project(e,n),f&&this._geometryQueryCache.put(f,e.items,e.items.length+1),e);if(!h)return y(null!=s?s:await this._getAllFeaturesQueryEngineResult(i));const g=this.featureAdapter;let _=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(a))),r);if("esriSpatialRelDisjoint"===u){if(!_.length)return y(null!=s?s:await this._getAllFeaturesQueryEngineResult(i));const e=new Set;for(const i of _)e.add(g.getObjectId(i));const t=null!=s?s.items:await this._reschedule((()=>this._getAllFeatures()),r),a=await this._reschedule((async()=>{const s=await v$4(u,h,this.geometryType,this.hasZ,this.hasM),a=t=>!e.has(g.getObjectId(t))||s(g.getGeometry(t)),n=await this._runSpatialFilter(t,a,r);return new z(n,i,this)}),r);return y(a)}if(null!=s){const i=new v$5;_=_.filter((e=>b$2(s.items,e,s.items.length,i)>=0));}if(!_.length){const e=new z([],i,this);return f&&this._geometryQueryCache.put(f,e.items,1),e}if(this._canExecuteSinglePass(h,i))return y(new z(_,i,this));const x=await v$4(u,h,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(_,(e=>x(g.getGeometry(e))),r);return y(new z(w,i,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||null==this.aggregateAdapter)return;const t=new Set;for(const s of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)));}const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))));}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))));}_executeTimeQuery(e){if(0===e.items.length)return;const t=n$2(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t));}_executeAttributesQuery(e){if(0===e.items.length)return;const t=y(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)));}}async _runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const u=e[s++];t(u)&&(r.push(u),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i);}};return this._reschedule((e=>a(e)),i).then((()=>r))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const u of e.items){const e=n(u,t),i=n(u,r),s=a.get(e);(!s||i>n(s,r))&&a.set(e,u);}e.items=Array.from(a.values());}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return I(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))}async _project(e,t){if(!t||S(this.spatialReference,t))return e;const i=this.featureAdapter,s=await M$2(e.items.map((e=>P(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t);return e.items=s.map(((t,s)=>i.cloneWithGeometry(e.items[s],rt(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(I(e)){if(m$3(e))return [a$2(e.xmin,e.ymin,e.xmax,e.ymax)];if(f$4(e))return e.rings.map((e=>a$2(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return [a$3(i$2(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _checkStatisticsSupport(e,t){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s$1(W,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t,e),P$1(e,this.geometryType,this.spatialReference),f$3(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e,t){let s=[];if(e.valueExpression){const{arcadeUtils:t}=await i();s=t.extractFieldNames(e.valueExpression);}if(e.field&&s.push(e.field),e.field2&&s.push(e.field2),e.field3&&s.push(e.field3),e.normalizationField&&s.push(e.normalizationField),!s.length&&!e.valueExpression)throw new s$1(W,"field or valueExpression is required",{params:e});m(this.fieldsIndex,s,{errorMessage:"Cannot calculate statistics for missing fields",query:t}),x(this.fieldsIndex,s,{expressionName:"statistics",query:t});}async _checkQuerySupport(e){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s$1(W,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([P$1(e,this.geometryType,this.spatialReference),f$3(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:r,outStatistics:a}=e,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(s&&s.length>0){const t=" asc",i=" desc",r=s.map((e=>{const s=e.toLowerCase();return s.includes(t)?s.split(t)[0]:s.includes(i)?s.split(i)[0]:e})).filter((e=>!n.includes(e)));m(this.fieldsIndex,r,{expressionName:"orderByFields",query:e});}if(t&&t.length>0)m(this.fieldsIndex,t,{expressionName:"outFields",query:e});else if(r)throw new s$1(W,"outFields should be specified for returnDistinctValues",{query:e});c(this.fieldsIndex,e.where,e);}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:r}=e,a$1=s&&s.length,n=t&&t.length;if(r){if(!a$1||!n)throw new s$1(W,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});f(this.fieldsIndex,r,t,e);}if(n){if(!$(t))return;const r=t.map((e=>e.onStatisticField)).filter(Boolean);m(this.fieldsIndex,r,{expressionName:"onStatisticFields",query:e}),a$1&&m(this.fieldsIndex,s,{expressionName:"groupByFieldsForStatistics",query:e});const n=new Set([...a.jsonValues,...l.jsonValues]),u=new Intl.ListFormat("en-US",{type:"conjunction"}).format([...a.apiValues,...l.apiValues]);for(const s of t){const{onStatisticField:t,statisticType:r}=s;if(("percentile_disc"===r||"percentile_cont"===r)&&"statisticParameters"in s){const{statisticParameters:t}=s;if(!t)throw new s$1(W,"statisticParameters should be set for percentile type",{definition:s,query:e})}else if("count"!==r&&"min"!==r&&"max"!==r&&t&&F(t,this.fieldsIndex,n))throw new s$1(W,`outStatistics with '${r}' statistic type, only supports ${u} field types`,{definition:s,query:e})}}}async _getQueryEngineResultForStats(e,t,i){e=a$1(e);try{e=await this._schedule((()=>v$3(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(r){if(r!==M$1)throw r;return new z([],e,this)}}}

export { ee as e };

//# sourceMappingURL=QueryEngine-3ab0312d.js.map