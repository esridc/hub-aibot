import { cv as V, O as j$1, j as s, cu as w, f as s$1, cA as r$1, aF as f, s as s$2, cz as Jt, iK as e, cG as o, aV as g$2, cF as u } from './hub-compass-map-f4225e12.js';
import { m, a as a$1, i as i$1, N as N$1, g as g$1 } from './External-818c40d3.js';
import './index-d436d5f8.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const r=1e6,a=20*r,n=2e9,i=3;async function p({data:p,name:c,description:l},m,d){let f=null;try{const u=V(m,"uploads"),h=V(u,"info"),{data:w$1}=await j$1(h,{query:{f:"json"},responseType:"json"});s(d);const y=w(m),j=w$1.maxUploadFileSize*r,g=y?n:j,q=y?Math.min(a,j):a;if(p.size>g)throw new Error("Data too large");const T=V(u,"register"),{data:z}=await j$1(T,{query:{f:"json",itemName:c,description:l},responseType:"json",method:"post"});if(s(d),!z.success)throw new Error("Registration failed");const{itemID:E}=z.item;f=V(u,E);const U=V(f,"uploadPart"),D=Math.ceil(p.size/q),M=new Array;for(let e=0;e<D;++e)M.push(p.slice(e*q,Math.min((e+1)*q,p.size)));const P=M.slice().reverse(),x=new Array,A=async()=>{for(;0!==P.length;){const o=M.length-P.length,s$1=P.pop(),r=new FormData;r.append("f","json"),r.append("file",s$1),r.append("partId",`${o}`);const{data:a}=await j$1(U,{timeout:0,body:r,responseType:"json",method:"post"});if(s(d),!a.success)throw new Error("Part upload failed")}};for(let e=0;e<i&&0!==P.length;++e)x.push(A());await Promise.all(x);const F=V(f,"commit"),{data:I}=await j$1(F,{query:{f:"json",parts:M.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if(s(d),!I.success)throw new Error("Commit failed");return I.item}catch(u){if(null!=f){const t=V(f,"delete");await j$1(t,{query:{f:"json"},responseType:"json",method:"post"});}throw u}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
async function g(e,t,s){return e.length?Promise.all(e.map((e=>T(e,t,s)))):[]}async function T(e,{layer:s,ongoingUploads:r},a){const o=r.get(e);if(o)return o;if(!P(s))throw new s$1(`${s.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(b(e,s))return e;const n=E(e,s,a);r.set(e,n);try{await n;}finally{r.delete(e);}return e}function b(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>m(e,s)))}async function E(e,t,s$1){const{metadata:a}=e,{displaySource:o}=a,n=x(o?.source,t),i=!!n,u=a.externalSources.length>0,l=i?$(n,t,s$1):u?F(e,t,s$1):j(e,t,s$1),c=await l;return s(s$1),e.addExternalSources([c]),e}async function $(e,t,s){return {source:await N(e,t,s),original:!0}}async function F(e,s,r){const a=B(s),{externalSources:o}=e.metadata,n=U(o,s);if(!n)throw new s$1(`${s.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const i=await N(n,s,r);e.addExternalSources([{source:i,original:!0}]);return {source:await q(i,s,a)}}async function j(e,t,s){const r=D(e,t,s);return {source:await A([r],t,s),extent:e.extent.clone(),original:!0}}async function D(e,t,s$1){const a=B(t),o=await e.load(s$1),n=await o.toBinaryGLTF({ignoreLocalTransform:!0});s(s$1);const i=await n.buffer();return s(s$1),{blob:new Blob([i.data],{type:i.type}),assetName:`${r$1()}.glb`,assetType:a}}function U(e,t){for(const s of e){const e=x(s.source,t);if(e)return e}return null}function x(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:r}}=t,a=N$1(e),o=new Array;let n=!1;for(let i=0;i<a.length;++i){const e=v(a[i],s);if(!e)return null;r.includes(e.assetType)&&(n=!0),o.push(e);}return n?o:null}function v(e,t){const s=g$1(e,t);return s?{asset:e,assetType:s}:null}async function N(e,t,s){return A(e.map((e=>S(e,s))),t,s)}async function A(e,t,s$1){const a=await Promise.all(e.map((async e=>{const a=I(await e,t,s$1);return s(s$1),a})));s(s$1);const{uploadResults:o}=await R(a.map((({item:e})=>e)),t,s$1);return s(s$1),e.map(((e,s)=>L(a[s],o[s],t)))}async function S(e,t){const{asset:s$1,assetType:a}=e;if(s$1 instanceof File)return {blob:s$1,assetName:s$1.name,assetType:a};const o=await s$1.toBlob(t);return s(t),{blob:o,assetName:s$1.assetName,assetType:a}}async function I(e,o,i){const{blob:u,assetType:l,assetName:c}=e;let p$1=null;try{const e=await p({data:u,name:c},o.url,i);s(i),p$1={assetType:l,assetUploadId:e.itemID};}catch(f$1){f(f$1),s$2.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${o.url} does not support the REST Uploads API.`);}if(!p$1){const e=await Jt(u);if(s(i),!e.isBase64)throw new s$1(`${o.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);p$1={assetType:l,assetData:e.data};}if(!p$1)throw new s$1(`${o.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return {item:p$1,assetName:c}}async function R(s$2,a,o){const n=await j$1(V(a.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(s$2)},method:"post",responseType:"json"});if(s(o),n.data.uploadResults.length!==s$2.length)throw new s$1(`${a.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${s$2.length} items and received ${n.data.uploadResults.length} results.`,new Error);return n.data}function L(e$1,s,r){const{success:a}=s;if(!a){const{error:a}=s;throw new s$1(`${r.type}-layer:upload-failure`,`Failed to upload mesh file ${e$1.assetName}. Error code: ${a.code}. Error message: ${a.messages}`,new Error)}const{assetHash:o}=s,{assetName:n,item:{assetType:i}}=e$1,{infoFor3D:{supportedFormats:u}}=r,l=e(i,u);if(!l)throw new s$1(`${r.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new a$1(n,l,[new i$1(`${r.parsedUrl.path}/assets/${o}`,o)])}async function q(s,r,a){const o$1=s.map((({assetName:e,parts:t})=>({assetName:e,assetHash:t[0].partHash}))),n=r.capabilities?.operations.supportsAsyncConvert3D,u={query:{f:"json",assets:JSON.stringify(o$1),transportType:"esriTransportTypeUrl",targetFormat:a,async:n},responseType:"json",timeout:0},l=V(r.parsedUrl.path,"convert3D"),c=(n?await C(l,u):await j$1(l,u)).data,{infoFor3D:{supportedFormats:d}}=r;return c.assets.map((e=>{const s=o(e.contentType,d);if(!s)throw new s$1(`${r.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new a$1(e.assetName,e.contentType,[new i$1(e.assetURL,e.assetHash)])}))}async function C(s,r){const a=(await j$1(s,r)).data.statusUrl;for(;;){const s=(await j$1(a,{query:{f:"json"},responseType:"json"})).data;switch(s.status){case"Completed":return j$1(s.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new s$1("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new s$1("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await g$2(H);}}function P(e){return !!e.infoFor3D&&!!e.url}function B(e){const{infoFor3D:s}=e,r=o("model/gltf-binary",s.supportedFormats)??u("glb",s.supportedFormats);if(!r)throw new s$1(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return r}const H=1e3;

export { g as uploadAssets };

//# sourceMappingURL=uploadAssets-008b90d8.js.map