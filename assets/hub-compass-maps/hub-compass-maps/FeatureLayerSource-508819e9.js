import { cn as q, c7 as s$1, co as _, cp as k$1, e as has, O as j, aB as R, cq as i, cr as n$1, cs as M, ct as c, cu as w, cv as V, f as s$2, aV as g, cw as o$1, aF as f, bv as Rn, cx as nn, cy as W, cz as Jt, s as s$3, cA as r$1, aE as f$2, cB as h, bW as p, cC as m$1, cD as b$1, a1 as e$1, a2 as y, a3 as a } from './hub-compass-map-f4225e12.js';
import { e } from './mat4f64-f2ca62fb.js';
import { m } from './MeshGeoreferencedRelativeVertexSpace-8823d711.js';
import { r } from './vec32-71093771.js';
import { A } from './External-818c40d3.js';
import { isFeatureIdentifierArrayWithGlobalId as b, isFeatureIdentifierArrayWithObjectId as f$1 } from './editingSupport-804efcf1.js';
import { o } from './clientSideDefaults-9a39a30b.js';
import { x } from './QueryTask-2d21d1b2.js';
import { s as s$4 } from './executeQueryJSON-d895488c.js';
import './index-d436d5f8.js';
import './QueryEngineCapabilities-3153ed38.js';
import './executeForIds-27b5a391.js';
import './query-2dbdcab5.js';
import './pbfQueryUtils-f0f40243.js';
import './pbf-2ae522ce.js';
import './OptimizedGeometry-d99be84d.js';
import './OptimizedFeatureSet-c30cfe93.js';
import './executeQueryPBF-7663f48b.js';
import './featureConversionUtils-aa77f433.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function n(t){const{vertexSpace:n}=t;if(n.isRelative)return t.clone();const{anchor:i}=t,c=i.clone(),a=q(s,[-c.x,-c.y,-c.z]),m$1=new m({origin:[c.x,c.y,c.z]}),p=t.cloneWithVertexSpace(m$1),{position:f}=p.vertexAttributes;return p.vertexAttributes.position=r(new Float64Array(f.length),f,a),p.vertexAttributesChanged(),p}const s=e();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const U=new s$1({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),k=new Set(["Feature Layer","Oriented Imagery Layer","Table"]),Q=new s$1({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let C=class extends _{constructor(){super(...arguments),this.type="feature-layer",this.refresh=k$1((async()=>{await this.load();const e=this.sourceJSON.editingInfo?.lastEditDate;if(null==e)return {dataChanged:!0,updates:{}};try{await this._fetchService(null);}catch{return {dataChanged:!0,updates:{}}}const t=e!==this.sourceJSON.editingInfo?.lastEditDate;return {dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map;}load(e){const t=null!=e?e.signal:null,s=this.layer.sourceJSON;return this.addResolvingPromise(this._fetchService(s,t)),Promise.resolve(this)}get queryTask(){const{capabilities:e,parsedUrl:t,dynamicDataSource:s,infoFor3D:r,gdbVersion:a,spatialReference:i,fieldsIndex:o}=this.layer,n=has("featurelayer-pbf")&&e?.query.supportsFormatPBF&&null==r,u=e?.operations?.supportsQueryAttachments??!1;return new x({url:t.path,pbfSupported:n,fieldsIndex:o,infoFor3D:r,dynamicDataSource:s,gdbVersion:a,sourceSpatialReference:i,queryAttachmentsSupported:u})}async addAttachment(e,t){await this.load();const s=e.attributes[this.layer.objectIdField],a=this.layer.parsedUrl.path+"/"+s+"/addAttachment",i=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(t,i.query);try{const e=await j(a,{body:o});return this._createFeatureEditResult(e.data.addAttachmentResult)}catch(n){throw this._createAttachmentErrorResult(s,n)}}async updateAttachment(e,t,s){await this.load();const a=e.attributes[this.layer.objectIdField],i=this.layer.parsedUrl.path+"/"+a+"/updateAttachment",o=this._getLayerRequestOptions({query:{attachmentId:t}}),n=this._getFormDataForAttachment(s,o.query);try{const e=await j(i,{body:n});return this._createFeatureEditResult(e.data.updateAttachmentResult)}catch(u){throw this._createAttachmentErrorResult(a,u)}}async applyEdits(e,t){await this.load();const{layer:a}=this,o=a.infoFor3D,n=null!=o,u=n||(t?.globalIdUsed??!1),l=n?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,d=e.addFeatures?.map((e=>this._getFeatureJSON(e,o)))??[],c=(await Promise.all(d)).filter(R),p=e.updateFeatures?.map((e=>this._getFeatureJSON(e,o)))??[],h=(await Promise.all(p)).filter(R),y=this._getFeatureIds(e.deleteFeatures,u);i(c,h,a.spatialReference);const m=await this._getAttachmentEditsJSON(e),f=a.capabilities.editing.supportsAsyncApplyEdits&&n,g={gdbVersion:t?.gdbVersion||a.gdbVersion,rollbackOnFailure:t?.rollbackOnFailureEnabled,useGlobalIds:u,returnEditMoment:t?.returnEditMoment,usePreviousEditMoment:t?.usePreviousEditMoment,sessionId:t?.sessionId,async:f};t?.returnServiceEditsOption?(g.edits=JSON.stringify([{id:a.layerId,adds:c,updates:h,deletes:y,attachments:m,assetMaps:l}]),g.returnServiceEditsOption=U.toJSON(t?.returnServiceEditsOption),g.returnServiceEditsInSourceSR=t?.returnServiceEditsInSourceSR):(g.adds=c.length?JSON.stringify(c):null,g.updates=h.length?JSON.stringify(h):null,g.deletes=y.length?u?JSON.stringify(y):y.join(","):null,g.attachments=m&&JSON.stringify(m),g.assetMaps=null!=l?JSON.stringify(l):void 0);const R$1=this._getLayerRequestOptions({method:"post",query:g}),S=t?.returnServiceEditsOption?a.url:a.parsedUrl.path,b=f?await this._asyncApplyEdits(S+"/applyEdits",R$1):await j(S+"/applyEdits",R$1);if(!a.capabilities.operations?.supportsEditing&&a.effectiveCapabilities?.operations?.supportsEditing){const e=n$1?.findCredential(a.url);await(e?.refreshToken());}return this._createEditsResult(b)}async deleteAttachments(e,t){await this.load();const s=e.attributes[this.layer.objectIdField],a=this.layer.parsedUrl.path+"/"+s+"/deleteAttachments";try{return (await j(a,this._getLayerRequestOptions({query:{attachmentIds:t.join(",")},method:"post"}))).data.deleteAttachmentResults.map(this._createFeatureEditResult)}catch(i){throw this._createAttachmentErrorResult(s,i)}}fetchRecomputedExtents(e={}){const t=e.signal;return this.load({signal:t}).then((async()=>{const t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:s,url:i}=this.layer,{data:o}=await j(`${i}/${s}`,t),{id:n,extent:u,fullExtent:l,timeExtent:d}=o,c$1=u||l;return {id:n,fullExtent:c$1&&M.fromJSON(c$1),timeExtent:d&&c.fromJSON({start:d[0],end:d[1]})}}))}async queryAttachments(e,t={}){await this.load();const s=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,s)}async queryFeatures(e,t){return await this.load(),this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!w(this.layer.url))return "unavailable";const e=V(this.layer.url,"status"),t=await j(e,{query:{f:"json"}});return Q.fromJSON(t.data.status)}async uploadAssets(e,t){const{uploadAssets:s}=await import('./uploadAssets-008b90d8.js');return s(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},t)}async _asyncApplyEdits(e,t){const s=(await j(e,t)).data.statusUrl;for(;;){const e=(await j(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return j(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new s$2("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new s$2("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await g(D);}}_createRequestQueryOptions(e){const t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){const{data:s}=await j(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:has("featurelayer-advanced-symbols")?{returnAdvancedSymbols:!0}:{},signal:t}));e=s;}this.sourceJSON=await this._patchServiceJSON(e,t);const s=e.type;if(!k.has(s))throw new s$2("feature-layer-source:unsupported-type",`Source type "${s}" is not supported`)}async _patchServiceJSON(e,t){if("Table"!==e.type&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){const t=o(e.geometryType).renderer;o$1("drawingInfo.renderer",t,e);}if("esriGeometryMultiPatch"===e.geometryType&&e.infoFor3D&&(e.geometryType="mesh"),null==e.extent)try{const{data:s}=await j(this.layer.url,this._getLayerRequestOptions({signal:t}));s.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:s.spatialReference});}catch(s){f(s);}return e}async _getFeatureJSON(e,t){const{geometry:s}=e,r={...e.attributes};if(null!=t&&"mesh"===s?.type){const{transformFieldRoles:e}=t,{origin:a,spatialReference:i,transform:o}=s,n=this.layer.spatialReference;await Rn(i,n);const u=nn(a,n);if(r[e.originX]=u.x,r[e.originY]=u.y,r[e.originZ]=u.z??0,null!=o){const{translation:t,scale:a,rotation:u}=o,{vertexSpace:l}=s,d=l.isGeoreferenced?1:W(i)/W(n);r[e.translationX]=t[0]*d,r[e.translationY]=-t[2]*d,r[e.translationZ]=t[1]*d,r[e.scaleX]=a[0],r[e.scaleY]=a[2],r[e.scaleZ]=a[1],r[e.rotationX]=u[0],r[e.rotationY]=u[2],r[e.rotationZ]=u[1],r[e.rotationDeg]=u[3];}return {geometry:null,attributes:r}}return null==s?{attributes:r}:"mesh"===s.type||"extent"===s.type?null:{geometry:s.toJSON(),attributes:r}}async _getAttachmentEditsJSON(e){const t=await Promise.all((e.addAttachments??[]).map((e=>this._getAttachmentEditJSON(e)))),s=await Promise.all((e.updateAttachments??[]).map((e=>this._getAttachmentEditJSON(e)))),r=e.deleteAttachments??[];return t.length||s.length||r.length?{adds:t,updates:s,deletes:[...r]}:null}async _getAttachmentEditJSON(e){const{feature:t,attachment:s}=e,{globalId:r,name:a,contentType:i,data:o,uploadId:n}=s,u={globalId:r,parentGlobalId:null,contentType:null,name:null,uploadId:null,data:null};if(t&&(u.parentGlobalId="attributes"in t?t.attributes&&t.attributes[this.layer.globalIdField]:t.globalId),n)u.uploadId=n;else if(o){const e=await Jt(o);e&&(u.contentType=e.mediaType,u.data=e.data),o instanceof File&&(u.name=o.name);}return a&&(u.name=a),i&&(u.contentType=i),u}async _uploadMeshesAndGetAssetMapEditsJSON(e){const{addAssetFeatures:t}=e;if(!t?.length)return null;const s=await this._filterRedundantAssetMaps(t);if(!t?.length)return null;const r=new Array,a=new Map;for(const i of s){const{geometry:e}=i,{vertexSpace:t}=e;if(t.isRelative)r.push(e);else {const t=n(e);a.set(t,e),i.geometry=t,r.push(t);}}await this.uploadAssets(r);for(const[i,o]of a)o.addExternalSources(i.metadata.externalSources.items);return {adds:this._getAssetMapEditsJSON(s),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){const t=new Array,s=this.layer.globalIdField,r=this.layer.parsedUrl;for(const a of e){const e=a.geometry,{metadata:i}=e,o=i.getExternalSourcesOnService(r),n=a.getAttribute(s);if(0===o.length){s$3.getLogger(this).error(`Skipping feature ${n}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:u}=o.find(A)??o[0],{vertexSpace:d}=e,c=d.isGeoreferenced?["PROJECT_VERTICES"]:[];for(const s of u)1===s.parts.length?t.push({globalId:r$1(),parentGlobalId:n,assetName:s.assetName,assetHash:s.parts[0].partHash,flags:c}):s$3.getLogger(this).error(`Skipping asset ${s.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);}return t}_getFeatureIds(e,t){if(!e||0===e.length)return [];if(t&&b(e))return e.map((e=>e.globalId));if(f$1(e))return e.map((e=>e.objectId));const{layer:s}=this,r=t?s.globalIdField:s.objectIdField;return r?e.map((e=>e.getAttribute(r))):[]}_createEditsResult(e){const t=e.data,{layerId:s}=this.layer,r=[];let a=null;if(Array.isArray(t))for(const u of t)r.push({id:u.id,editedFeatures:u.editedFeatures}),u.id===s&&(a={addResults:u.addResults??[],updateResults:u.updateResults??[],deleteResults:u.deleteResults??[],attachments:u.attachments,editMoment:u.editMoment});else a=t;const i=a?.assetMaps;if(i){for(const e of i.addResults)e.success||s$3.getLogger(this).error(`Failed to map asset to feature with globalId ${e.globalId}.`);for(const e of i.updateResults)e.success||s$3.getLogger(this).error(`Failed to map asset to feature with globalId ${e.globalId}.`);}const o=a?.attachments,n={addFeatureResults:a?.addResults?.map(this._createFeatureEditResult,this)??[],updateFeatureResults:a?.updateResults?.map(this._createFeatureEditResult,this)??[],deleteFeatureResults:a?.deleteResults?.map(this._createFeatureEditResult,this)??[],addAttachmentResults:o&&o.addResults?o.addResults.map(this._createFeatureEditResult,this):[],updateAttachmentResults:o&&o.updateResults?o.updateResults.map(this._createFeatureEditResult,this):[],deleteAttachmentResults:o&&o.deleteResults?o.deleteResults.map(this._createFeatureEditResult,this):[]};if(a?.editMoment&&(n.editMoment=a.editMoment),r.length>0){n.editedFeatureResults=[];for(const e of r){const{editedFeatures:t}=e,s=t?.spatialReference?new f$2(t.spatialReference):null;n.editedFeatureResults.push({layerId:e.id,editedFeatures:{adds:t?.adds?.map((e=>this._createEditedFeature(e,s)))||[],updates:t?.updates?.map((e=>({original:this._createEditedFeature(e[0],s),current:this._createEditedFeature(e[1],s)})))||[],deletes:t?.deletes?.map((e=>this._createEditedFeature(e,s)))||[],spatialReference:s}});}}return n}_createEditedFeature(e,s){return new h({attributes:e.attributes,geometry:p({...e.geometry,spatialReference:s})})}_createFeatureEditResult(e){const t=!0===e.success?null:e.error||{code:void 0,description:void 0};return {objectId:e.objectId,globalId:e.globalId,error:t?new s$2("feature-layer-source:edit-failure",t.description,{code:t.code}):null}}_createAttachmentErrorResult(e,t){const s=t.details.messages&&t.details.messages[0]||t.message,r=t.details.httpStatus||t.details.messageCode;return {objectId:e,globalId:null,error:new s$2("feature-layer-source:attachment-failure",s,{code:r})}}_getFormDataForAttachment(e,t){const s=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(s)for(const r in t){const e=t[r];null!=e&&(s.set?s.set(r,e):s.append(r,e));}return s}_getLayerRequestOptions(e={}){const{parsedUrl:t,gdbVersion:s,dynamicDataSource:r}=this.layer;return {...e,query:{gdbVersion:s,layer:r?JSON.stringify({source:r}):void 0,...t.query,f:"json",...this._createRequestQueryOptions(e)},responseType:"json"}}async _filterRedundantAssetMaps(e){const{layer:t}=this,{globalIdField:s,infoFor3D:r,parsedUrl:a}=t;if(null==r||null==s)return e;const o=m$1(r);if(null==o)return e;const n=V(a.path,`../${o.id}`),u=new Array,l=new Array;for(const i of e)i.geometry.metadata.getExternalSourcesOnService(a).length>0?l.push(i):u.push(i);const d=l.map((e=>e.getAttribute(s))).filter(R);if(0===d.length)return e;const{assetMapFieldRoles:{parentGlobalId:c,assetHash:p}}=r,h=new b$1;h.where=`${c} IN (${d.map((e=>`'${e}'`))})`,h.outFields=[p,c],h.returnGeometry=!1;const y=await s$4(n,h),{features:f}=y;return 0===f.length?e:[...u,...l.filter((e=>{const t=e.getAttribute(s);if(!t)return !0;const{metadata:r}=e.geometry,i=f.filter((e=>e.getAttribute(c)===t));if(0===i.length)return !0;const o=i.map((e=>e.getAttribute(p)));return r.getExternalSourcesOnService(a).flatMap((({source:e})=>e.flatMap((e=>e.parts.map((e=>e.partHash)))))).some((e=>o.every((t=>e!==t))))}))]}};e$1([y()],C.prototype,"type",void 0),e$1([y({constructOnly:!0})],C.prototype,"layer",void 0),e$1([y({readOnly:!0})],C.prototype,"queryTask",null),C=e$1([a("esri.layers.graphics.sources.FeatureLayerSource")],C);const D=1e3,L=C;

export default L;

//# sourceMappingURL=FeatureLayerSource-508819e9.js.map